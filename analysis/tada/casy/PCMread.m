function [signal, sRate, hdr] = PCMread(fileName, ignorePeriod)%PCMREAD  - read a Haskins format PCM file%%	 usage:  [signal, sRate, hdr] = PCMread(fileName, ignorePeriod)%% FILENAME specifies the PCM file to load% if FILENAME contains the '*' character it is interpreted as a mask% use PCMread (no argument) to select file interactively using dialog box%% PCMREAD uses the header period field to set the sampling rate if available% which may lead to inaccurate or undesired results; specify non-zero IGNOREPERIOD % to force the sampling rate to the header frate contents%% returns the (scaled and offset) signal vector and sampling rate (Hz)% HDR is an optional returned struct giving PCM header fields%% see also PCMWRITE% mkt 10/97%	constantsmask = '*.pcm';				% PCM file maskbyteOrder = 'vaxd';			% file byte order% changed '*.PCM' to '*.pcm' YuKM 07/2003 %	load filename if necessaryif nargin < 1, fileName = []; end;if nargin<2 | isempty(ignorePeriod), ignorePeriod = 0; end;if findstr(fileName, '*'),	mask = fileName;	fileName = [];end;if isempty(fileName),	[file, pathName] = uigetfile(mask, 'Select Haskins format PCM file');	if file == 0, return; end;	fileName = [pathName file];end;%	open file[fid, msg] = fopen(fileName, 'rb', byteOrder);if fid == -1,	error([msg, ' (', fileName, ')']);end;%	parse PCM headerfread(fid, 1, 'int16');				% skip (type)nSamps = fread(fid, 1, 'int32');		% number of samples (tfrms)hdr1 = fread(fid, [1 71], 'uint16');	% read everything up to calmhdr2 = fread(fid, [1 2], 'float32');	% read scale (calm), offset (calb)if hdr1(12)>0 & ~ignorePeriod,			% sampling rate	sRate = 1e6/hdr1(12);					% use period field if available	if sRate ~= hdr1(1),		fprintf('Warning: header sampling rate is %d, rate derived from period is %g; using %d Hz\n', ...			hdr1(1), sRate, round(sRate));	end;else,	sRate = hdr1(1);				% else frateend;resolution = hdr1(10);				% # bits resolution (default = 12)if resolution ~= 16, resolution = 12; end;scale = hdr2(1);					% scaleoffset = hdr2(2);					% offset%	load header if user wants it%	PCM headerif nargout == 3,	fseek(fid, 0, 'bof');			% reset file ptr	hdr.type = fread(fid, 1, 'int16');			% file type	hdr.tfrms = fread(fid, 1, 'uint32');		% number of samples	hdr.frate = fread(fid, 1, 'uint16');		% sampling rate (Hz)	flags = fread(fid, 1, 'uint16');				hdr.atrib = struct( ...						% data attributes		'noemp', bitget(flags, 1), ...			% nonzero ==> no pre-emphasis		'nofil', bitget(flags, 2) );			% nonzero ==> no filtering	hdr.nahdrblk = fread(fid, 1, 'int16');		% number of additional header blocks	hdr.nlabels = fread(fid, 1, 'int16');		% number of WENDY labels	hdr.revlvl = fread(fid, 1, 'int16');		% header revision level	hdr.vbntrlr = fread(fid, 1, 'uint32');		% virtual block number of first trailer	hdr.ntrlrblk = fread(fid, 1, 'int16');		% number of trailer blocks	hdr.source = fread(fid, 1, 'int16');		% data source	hdr.resolution = fread(fid, 1, 'int16');	% number of bits of sampling resolution	hdr.srcpure = fread(fid, 1, 'int16');		% source modified if not zero	hdr.period = fread(fid, 1, 'uint16');		% sampling period in microsecs	fread(fid, 49, 'int16');					% (filler)	hdr.imode = fread(fid, 1, 'int16');			% Datel hardware input mode	fread(fid, 5, 'int16');						% (filler)	hdr.psphvn = fread(fid, 1, 'int16');		% PSP header version number 	hdr.smpf = fread(fid, 1, 'int16');			% samples per frame	hdr.chmap = fread(fid, 1, 'int16');			% channel map	hdr.drcsz = fread(fid, 1, 'int16');			% data file record size	hdr.calm = fread(fid, 1, 'float32');		% M calibration constant (scaling)	hdr.calb = fread(fid, 1, 'float32');		% B calibration constant (offset)	hdr.units = deblank(char(fread(fid, 12, 'char')));	% calibration units	hdr.idxnm = deblank(char(fread(fid, 32, 'char')));	% index file name	hdr.smc = fread(fid, 1, 'float32');			% smoothing constant	hdr.lup = fread(fid, 1, 'int32');			% line-up point	hdr.ymin = fread(fid, 1, 'float32');		% graphics scaling -- y-min	hdr.ymax = fread(fid, 1, 'float32');		% graphics scaling -- y-max	hdr.nvpf = fread(fid, 1, 'int32');			% DFT window size	hdr.skip = fread(fid, 1, 'int32');			% sample skip between frames	hdr.dframes = fread(fid, 1, 'int32');		% # DFT frames	hdr.dwint = fread(fid, 1, 'int32');			% DFT window typeend;%	read signalfseek(fid, 512, 'bof');				% start of signal data[signal, n] = fread(fid, nSamps, 'uint16');fclose(fid);						% done with fileif n ~= nSamps,						% make sure we read all expected samples	error(['Sample read mismatch:  expected ', int2str(nSamps), ', read ', int2str(n)]);end;%	convert 12bit data from 2048 offset to 0 offsetif resolution == 12	signal = signal - 2048;end;%	is this speech?if scale == 0 | (scale == 1 & offset == 0),	return;end;%	scale non-speech datasignal = signal*scale + offset;